#!/usr/bin/node
/* vim: set ft=javascript: */
/*
 * Purpose   : Run hi_score lifecycle tools
 * Example   : See xhi help
 * Author    : Michael S. Mikowski - mike.mikowski@gmail.com
 *
*/
/*jslint node : true */
/*global Promise */
// == BEGIN SCRIPT xhi - the hi_score cli life-stage tool ==============
// == BEGIN MODULE SCOPE VARIABLES =====================================
'use strict';
var
  // Load core libraries
  childProcObj = require( 'child_process' ),
  fsObj        = require( 'fs'            ),
  npmObj       = require( 'npm'           ),
  pathObj      = require( 'path'          ),
  readlineObj  = require( 'readline'      ),
  utilObj      = require( 'util'          ),

  makeSpawnObj  = childProcObj.spawn,
  PromiseObj    = Promise,

  // Use promisify to create promise-returning functions
  promisifyFn    = utilObj.promisify,
  makeReadPromFn = promisifyFn( fsObj.readFile ),
  // Consider using eventObj = new EventEmitter(),

  // Get environment values
  fqAppFilename = __filename,
  fqBinDirname  = __dirname,

  appName       = pathObj.basename( fqAppFilename, '.js' ),
  argList       = process.argv,
  fqOrigDirname = process.cwd(), // or pathObj.resolve()
  padName       = '    ' + appName,
  promptStr     = appName + '> ',
  versList      = process.versions.node.split('.'),

  // Set paths
  fqProjDirname   = pathObj.dirname( fqBinDirname ),
  fqHookFilename  = fqProjDirname + '/.git/hooks/pre-commit',
  fqLibDirname    = fqProjDirname   + '/lib',
  fqModuleDirname = fqProjDirname   + '/node_modules',
  fqPkgFilename   = fqProjDirname   + '/package.json',
  fqStateFilename = fqLibDirname    + '/xhi_state.json',

  // Set data
  binPathMap       = {}, // List of required external executables
  jsonDataMap      = {}, // Map of JSON read from files
  minVersionInt    = 8,  // minimum Node version

  // Example build_table entry
  // { "build_id"    : "000000001",
  //   "comment_str" : "Example build",
  //   "is_acvtive"  : false,
  //   "time_int_ms" : 1504241954754,
  //   "time_str"    : "2017-09-01 12:36:45"
  // }
  emptyStateMatrix = {
    "build_idx"        : 1,
    "build_table"      : [],
    "stage_status_map" : {}
  },

  // Declare curried functions
  abortFn, exitFn, logFn, warnFn,

  // Declare config data
  commandTable,

  // Declare after-install-variables
  LineReader,     applyPatchFn,  exeCpeFn,
  flowObj,        makeWhichProm, mkdirpFn,
  ncpFn,          psObj,         rmDirFn,
  shellJsObj,     whichFn,
  xhiLibMap,      xhiUtilObj
  ;

global.xhi = require( fqProjDirname + '/js/xhi/00.js' );
require( fqProjDirname + '/js/xhi/01.util.js' );
xhiLibMap = global.xhi._makeRoot_( 'xhiLibMap' );
global.xhi._makeUtil_( xhiLibMap );
xhiUtilObj = xhiLibMap._util_;
// == . END MODULE SCOPE VARIABLES =====================================

// == BEGIN UTILITY METHODS ============================================
// BEGIN utilities /writePkgFileFn/ and /writeStateFileFn/
function writePkgFileFn ( onwrite_fn ) {
  var package_str = JSON.stringify( jsonDataMap.package_matrix, null, '  ' );
  fsObj.writeFile(
    fqPkgFilename, package_str, { encoding : 'utf8' }, onwrite_fn
  );
}

function writeStateFileFn ( onwrite_fn ) {
  var state_str = JSON.stringify( jsonDataMap.state_matrix, null, '  ' );
  fsObj.writeFile(
    fqStateFilename, state_str, { encoding : 'utf8' }, onwrite_fn
  );
}
// END utilities /writePkgFileFn/ and /writeStateFileFn/

// BEGIN utility /makeRightPadStr/
function makeRightPadStr ( arg_str, arg_count ) {
  var
    delta_count = arg_count - arg_str.length,
    delta_list  = []
    ;

  delta_list.length = delta_count > 0 ? delta_count : 0;
  return arg_str + delta_list.join(' ');
}
// . END utility /makeRightPadStr/

// BEGIN utility /_outFn/
// Purpose: provides abortFn, exitFn, logFn, and warnFn
function _outFn() {
  var
    ctx_obj    = this || {},
    method_str = ctx_obj.method_str || 'log',
    prompt_str = ctx_obj.prompt_str || promptStr,
    arg_list   = Array.from( arguments )
    ;

  function consider_exit_fn () {
    if ( ctx_obj.do_abort ) { process.exit( 1 ); }
    if ( ctx_obj.do_exit  ) { process.exit( 0 ); }
  }

  if ( arg_list.length > 0 ) {
    arg_list.unshift( prompt_str );
    console[ method_str ].apply( null, arg_list );
  }
  if ( ctx_obj.cd_name ) {
    process.chdir( ctx_obj.cd_name );
  }
  if ( ( ctx_obj.do_abort || ctx_obj.do_exit ) ) {
    writeStateFileFn( consider_exit_fn );
  }
  else {
    consider_exit_fn();
  }
}
abortFn = _outFn.bind({
  cd_name      : fqOrigDirname,
  do_abort     : true,
  method_str   : 'warn',
  prompt_str   : appName + '-abort> '
});
exitFn = _outFn.bind({
  cd_name      : fqOrigDirname,
  do_exit      : true,
  prompt_str   : appName + '-exit> '
});
logFn   = _outFn.bind({});
warnFn  = _outFn.bind({
  method_str : 'warn',
  prompt_str : appName + '-warn> '
});
// . END utility /_outFn/

// BEGIN utility /askFn/
// Purpose: Wrap readObj question with prompt
//
function askFn ( ask_str, response_fn ) {
  var read_obj = readlineObj.createInterface({
    input  : process.stdin,
    output : process.stdout
  });

  read_obj.question(
    promptStr + ask_str,
    function ( str ) {
      read_obj.close();   // Relinquish readline control of stdio
      response_fn( str );
    }
  );
}
// . END utilities /askFn/

// BEGIN utility /makeCommandTable/
// Purpose: Create data structure to look up command details
//
function makeCommandTable ( raw_table ) {
  var
    head_list   = raw_table[ 0 ],
    head_count  = head_list.length,
    prefix_str  = '\n' + promptStr + '   ',
    solve_table = [],
    raw_count   = raw_table.length,

    idx, row_list, solve_id, solve_map,
    jdx, field_key, field_data, solve_str,
    alias_list, alias_str
    ;

  for ( idx = 1; idx < raw_count; idx++ ) {
    row_list = raw_table[ idx ];
    solve_id   = String( idx - 1 );
    if ( solve_id.length < 2 ) { solve_id = '0' + solve_id; }
    solve_map = { id : solve_id, idx : idx - 1  };

    FIELD: for ( jdx = 0; jdx < head_count; jdx++ ) {
      field_key  = head_list[ jdx ];
      field_data = row_list[  jdx ];
      if ( field_key.match( /_str$/ ) ) {

        // Join array into multi-line string
        if ( Array.isArray( field_data ) ) {
          solve_str = prefix_str + field_data.join( prefix_str );
        }
        else {
          solve_str = String( field_data );
        }

        // Template replace
        solve_str = xhiUtilObj._makeTmpltStr_({
          _input_str_  : solve_str,
          _lookup_map_ : {
            appName : appName,
            padName : padName
          }
        });
        solve_map[ field_key ] = solve_str;
        continue FIELD;
      }
      solve_map[ field_key ] = field_data;
    }
    alias_list = solve_map.alias_list || [];
    alias_str  = alias_list[ 0 ]      || '';
    solve_map.alias_str = alias_str;

    solve_table.push( solve_map );
  }
  return solve_table;
}
// . END utility /makeCommandTable/

// BEGIN utility /filterByAlias/
function filterByAlias ( map ) {
  return ( map.alias_list.indexOf( this ) > -1 );
}
// . END utility /filterByAlias/

// BEGIN utility /getCommandMapFn/
function getCommandMapFn ( row_id ) {
  var
    idx = parseInt( row_id, 10 ),
    filter_list
    ;

  if ( isNaN( idx ) ) {
    filter_list = commandTable.filter( filterByAlias, row_id );
  }
  else {
    filter_list = [ commandTable[ idx ] ];
  }
  return filter_list[ 0 ];
}
// . END utility /getCommandMapFn/

// BEGIN utility /makePrefixStr/
function makePrefixStr ( command_map ) {
  // noinspection MagicNumberJS
  return 'Stage ' + command_map.id + ' '
    + makeRightPadStr( command_map.alias_str, 12 ) + ': '
    ;
}
// . END utility /makePrefixStr/

// BEGIN utility /makeParamMap/
// Purpose   : Process command line arguments
// Example   : makeParamMap( [ 'help', '1', '-v' ] )
//   returns : { do_verbose: true, range_str : '1',
//               stage_list : [ <commandRowHelp> ] }
// Example   : makeParamMap( [ '1', '-v' ] )
//   returns : { do_verbose: true, range_str : '1'
//               stage_list : [ <commandRow1> ] }
// Arguments : (positional)
//   0) stage_list - list of command line arguments and switches
//   1) skip_idx   - skip this number of arguments (not switches)
// Returns   :  An object as follows:
//   { do_verbose : <true|false>,
//     range_str  : <cli_range_provided>,
//     stage_list : [  <commandRow0>, <commandTableRow1, ...  ]
//   }
function makeParamMap ( param_list, arg_skip_idx ) {
  var
    arg_count  = 0,
    skip_idx   = arg_skip_idx || 0,

    do_verbose = false,
    range_str  = '',
    stage_list = null,

    edge_list, temp_list
    ;

  param_list.forEach( function ( str, ignore_idx ) {
    var i, first_map, middle_map, last_map, first_idx, last_idx;
    if ( str === '-v' ) {
      do_verbose = true;
      return;
    }

    // skip range list if already defined
    if ( stage_list ) { return true; }

    if ( str.match(/-/) || str === 'all' ) {
      if ( arg_count < skip_idx ) {
        arg_count++;
        return;
      }

      edge_list = str === 'all'
        ? [ 0, commandTable.length - 1 ]
        : str.split( '-', 2 );

      first_map = getCommandMapFn( edge_list[ 0 ] );
      last_map  = getCommandMapFn( edge_list[ 1 ] );
      if ( ! first_map ) {
        return warnFn( 'Range stage ' + edge_list[ 0 ] + ' is invalid' );
      }
      if ( ! last_map ) {
        return warnFn( 'Range stage ' + edge_list[ 1 ] + ' is invalid' );
      }
      if ( first_map.idx > last_map.idx ) {
        return warnFn(
          'Range start start ' + edge_list[ 0 ]
          + ' exceeds stage end ' + edge_list[ 1 ]
        );
      }

      temp_list = [ first_map ];

      first_idx = first_map.idx + 1;
      last_idx  = last_map.idx  - 1;

      for ( i = first_idx; i <= last_idx; i++ ) {
        middle_map = getCommandMapFn( i );
        if ( ! middle_map ) { return; }
        temp_list.push( middle_map );
      }
      if ( last_map !== first_map ) {
        temp_list.push( last_map );
      }

      range_str  = str;
      stage_list = temp_list;
      return;
    }

    if ( str.match(/,/) ) {
      if ( arg_count < skip_idx ) {
        arg_count++;
        return;
      }
      edge_list = str.split(',');
      temp_list = [];
      edge_list.forEach( function ( data, ignore_idx ) {
        middle_map = getCommandMapFn( data );
        if ( ! middle_map ) { return; }
        temp_list.push( middle_map );
      });

      range_str  = str;
      stage_list = temp_list;
      return;
    }

    if ( arg_count < skip_idx ) {
      arg_count++;
      return;
    }
    middle_map = getCommandMapFn( str );
    if ( ! middle_map ) { return; }

    range_str  = str;
    stage_list = [ middle_map ];
  });

  return {
    do_verbose : do_verbose,
    range_str  : range_str,
    stage_list : stage_list || []
  };
}
// . END utility /makeParamMap/

// BEGIN utlity /grepFileFn/
// Purpose : Return a promise that provides the resolve function with
// a list of lines in a file that match a regex pattern
//
function grepFileFn ( filename, pattern_str ) {
  return new PromiseObj ( function ( resolve_fn, catch_fn ) {
    var
      line_read_obj = new LineReader( filename, {skipEmptyLines:true }),
      pattern_rx    = new RegExp( pattern_str ),
      match_list    = []
      ;

    line_read_obj.on( 'error', catch_fn );
    line_read_obj.on( 'line',  function ( line_str ) {
      if ( line_str.match( pattern_rx ) ) {
        match_list.push( line_str );
      }
    });
    line_read_obj.on( 'end', function () {
      resolve_fn( match_list );
    });
  });
}
// . END utility /grepFileFn/

// BEGIN utility /copyPathFn/
function copyPathFn( fq_src_path_str, fq_dest_path_str, do_dir_copy ) {
  if ( do_dir_copy ) {
    return new PromiseObj ( function ( resolve_fn, reject_fn ) {
      ncpFn( fq_src_path_str, fq_dest_path_str,
        function ( error_data ) {
          if ( error_data ) { return reject_fn(); }
          resolve_fn();
        }
      );
    });
  }

  return new PromiseObj ( function ( resolve_fn, reject_fn ) {
    var
      read_obj = fsObj.createReadStream(  fq_src_path_str  ),
      write_obj= fsObj.createWriteStream( fq_dest_path_str );

    read_obj.on(  'error', reject_fn  );
    write_obj.on( 'error', reject_fn  );
    write_obj.on( 'close', resolve_fn );
    read_obj.pipe( write_obj );
  });
}
// . END utility /copyPathFn/

// BEGIN utility /storePathFn/
function storePathFn ( path_str ) {
  var
    ctx_obj = this,
    bin_key = ctx_obj.bin_key;

  if ( ! bin_key ) {
    abortFn( 'No key provided for ' + path_str );
  }
  binPathMap[ bin_key ]  = path_str;
}
// . END utility /storePathFn/

// BEGIN utility /storeJsonFn/
function storeJsonFn ( json_str ) {
  var ctx_obj = this;
  jsonDataMap[ ctx_obj.key ] = JSON.parse( json_str ) || {};
}
// . END utility /storeJsonFn/

// BEGIN utility /loadPostInstallfn/
// Loads libraries after stage 01 (install) is complete
function loadLibsFn () {
  LineReader   = require( 'line-by-line'      );
  applyPatchFn = require( 'apply-patch'       ).applyPatch;
  exeCpeFn     = require( 'execpe'            );
  flowObj      = require( 'flow'              );
  mkdirpFn     = require( 'mkdirp'            );
  ncpFn        = require( 'ncp'               ).ncp;
  psObj        = require( 'ps-node'           );
  rmDirFn      = require( 'rmdir'             );
  shellJsObj   = require( 'shelljs'           );
  whichFn      = require( 'which'             );
  makeWhichProm = promisifyFn( whichFn );
}
// . END utility /loadLibsFn/

// BEGIN utility /checkBinListFn/
function checkBinListFn () {
  var
    ctx_obj      = this,
    exe_list     = [ 'git', 'patch' ],
    exe_count    = exe_list.length,
    promise_list = [],

    idx, bin_key, bound_fn, promise_obj;

  // Assign executable path vars
  for ( idx = 0; idx < exe_count; idx++ ) {
    bin_key     = exe_list[ idx ];
    bound_fn    = storePathFn.bind( { bin_key : bin_key });
    promise_obj = makeWhichProm( bin_key );
    promise_obj.then( bound_fn ).catch( abortFn );
    promise_list.push( promise_obj );
  }

  PromiseObj.all( promise_list )
    .then(  ctx_obj.then_fn  )
    .catch( ctx_obj.catch_fn )
    ;
}
// . END utility /checkBinListFn/

// BEGIN utility /checkNodeVersionFn/
function checkNodeVersionFn () {
  var abort_str;
  if ( Number( versList[0] ) < minVersionInt ) {
    abort_str
      = 'NodeJS Version ' + versList.join('.') + ' is installed.\n'
      + 'As of ' + appName + '1.2 NodeJS v'
      + minVersionInt + ' is required.\n'
      + 'Please upgrade NodeJS and try again.'
      ;
    abortFn( abort_str );
  }
}
// . END utility /checkNodeVersionFn/

// == END UTILITY METHODS ==============================================

// == BEGIN EVENT HANDLERS =============================================
// == . END EVENT HANDLERS =============================================

// BEGIN utility /makePostObj/
// Purpose: Creates resource map for modules available
//   only after npm install.
//
function makePostObj () {
  return {
    applyPatchFn      : applyPatchFn,
    binPathMap        : binPathMap,        // --  ?
    checkBinListFn    : checkBinListFn,    // 02 setup
    copyPathFn        : copyPathFn,        // 02 setup
    exeCpeFn          : exeCpeFn,          // --  ?
    flowObj           : flowObj,           // 02 setup
    mkdirpFn          : mkdirpFn,          // 02 setup
    grepFileFn        : grepFileFn,        // 02 setup, 06 lint
    psObj             : psObj,             // 06 dev_start
    rmDirFn           : rmDirFn,           // 02 setup
    shellJsObj        : shellJsObj,        // 11 build
    writePkgFileFn    : writePkgFileFn,    // 05 upgrade
    writeStateFileFn  : writeStateFileFn   // 05 upgrade
  };
}
// . END utility /makePostObj/

// BEGIN utility /makeXhiObj/
// Purpose: Create object to provide as context to lib functions
//  nextFn and catchFn are defaults.
//
function makeXhiObj () {
  var
    status_map = xhiUtilObj._getStructData_(
      jsonDataMap, [ 'state_matrix', 'stage_status_map' ]
    ) || {},
    build_table = xhiUtilObj._getStructData_(
      jsonDataMap, [ 'state_matrix', 'build_table' ]
    )|| {},
    package_matrix = jsonDataMap.package_matrix || {}
    ;

  return {
    appName         : appName,          // Applicaiton name
    askFn           : askFn,            // Read line with prompt
    buildTable      : build_table,      // xhi_state.json build records
    catchFn         : abortFn,          // Fn for error
    childProcObj    : childProcObj,     // child_process object
    commandMap      : null,             // Command map of lib to exec
    fqBinDirname    : fqBinDirname,     // Full path of bin scripts
    fqHookFilename  : fqHookFilename,   // Full path to commit hook
    fqModuleDirname : fqModuleDirname,  // Full path to node modules
    fqOrigDirname   : fqOrigDirname,    // Full path of PWD
    fqPkgFilename   : fqPkgFilename,    // Full path to package.json
    fqProjDirname   : fqProjDirname,    // Full path of root project dir
    fsObj           : fsObj,            // File system object
    getCommandMapFn : getCommandMapFn,  // Get command map by id or index
    loadLibsFn      : loadLibsFn,       // Load libs after stage 1
    logFn           : logFn,            // Log to console
    makePrefixStr   : makePrefixStr,    // Fn for stage prefix
    makeRightPadStr : makeRightPadStr,  // Pad string right
    makeSpawnObj    : makeSpawnObj,     // Object create spawned proc
    makePostObj     : makePostObj,      // Get utils after stage 1
    nextFn          : exitFn,           // Fn for success
    npmObj          : npmObj,           // Npm API object
    paramMap        : null,             // Parameters per CLI input
    PromiseObj      : PromiseObj,       // Promise object
    promisifyFn     : promisifyFn,      // Promisify from utils
    packageMatrix   : package_matrix,   // package.json data
    stageStatusMap  : status_map,       // xhi_state.json stage data
    warnFn          : warnFn            // Warn to console
  };
}
// . END utility /makeXhiObj/

// == BEGIN INIT METHOD ================================================
// Purpose: reads JSON files in source list and stores them
//   to the module scope using storeJsonFn
//
function initReadFn () {
  var
    ctx_obj      = this,
    source_list  = [
      { key : 'package_matrix', filename: fqPkgFilename },
      { key : 'state_matrix',   filename: fqStateFilename }
    ],
    source_count   = source_list.length,
    promise_list = [],

    idx, row_map, promise_obj, bound_fn;

  for ( idx = 0; idx < source_count; idx++ ) {
    row_map      = source_list[ idx ];
    bound_fn     = storeJsonFn.bind( row_map );
    promise_obj  = makeReadPromFn( row_map.filename, 'utf8' );
    promise_obj.then( bound_fn ).catch( abortFn );
    promise_list.push( promise_obj );
  }
  PromiseObj.all( promise_list ).then( ctx_obj.then_fn ).catch( abortFn );
}
// == . END INIT METHOD =============================================

// == BEGIN PUBLIC METHOD /mainFn/ ==================================
// Purpose   : Parse command line and dispatch to requested command(s)
function mainFn () {
  var
    param_list        = argList.slice( 2 ),
    exec_list         = [],
    range_start_str   = '',
    range_success_str = '',
    stage_idx         = 0,
    package_matrix    = jsonDataMap.package_matrix,
    prereq_type_list  = [ 'predo_list', 'prereq_list' ],
    prereq_type_count = prereq_type_list.length,

    stage_status_map = xhiUtilObj._getStructData_(
      jsonDataMap, [ 'state_matrix', 'stage_status_map' ]
    ) || {},

    param_map,   stage_list,  command_map,
    xhi_obj,     stage_fn,    stage_count,

    alias_str, prereq_count, prereq_idx,
    prereq_list,  prereq_type,  type_idx,

    bound_fn, prefix_str
    ;

  // Create command table from config
  commandTable = makeCommandTable( package_matrix.xhi_commandTable );

  // Abort if node version < minVersionInt
  checkNodeVersionFn();

  param_map    = makeParamMap( param_list ); // cli parameters
  stage_list   = param_map.stage_list;       // stage list from range
  command_map  = stage_list[ 0 ];            // first stage
  xhi_obj      = makeXhiObj();               // context obj for libs

  // Begin run in help mode
  if ( ! command_map
    || param_map.range_str === ''
    || param_map.range_str.match(/^0+$/)
    || param_map.range_str === 'help'
  ) {
    command_map = getCommandMapFn( 0 );
    xhi_obj.commandMap = command_map;
    xhi_obj.paramMap   = makeParamMap( param_list, 1 );
    xhi_obj.doListShow = true;
    stage_fn = require( fqLibDirname + '/xhi_00.js' );
    return stage_fn.call( xhi_obj );
  }
  // . End run in help mode

  // Begin expand stage list to resolve all dependencies then sort.
  // predo_list  : Stages that must be added to the stage_list
  //   every time this stage is run.
  // prereq_list : List of stages to add to the stage_list if they
  //   their most recent run failed.
  //
  stage_count = stage_list.length;
  while ( stage_idx < stage_count ) {
    for ( type_idx = 0; type_idx < prereq_type_count; type_idx++ ) {
      prereq_type  = prereq_type_list[ type_idx ];
      prereq_list  = command_map[ prereq_type ] || [];
      prereq_count = prereq_list.length;

      for ( prereq_idx = 0; prereq_idx < prereq_count; prereq_idx++ ) {
        command_map  = getCommandMapFn( prereq_list[ prereq_idx ] );
        alias_str = command_map.alias_str;

        // Skip any environment prereq that is completed
        if ( prereq_type === 'prereq_list'
          && stage_status_map[ alias_str ]
        ) { continue; }

        // Push prereq to end of list for further resolution
        if ( stage_list.indexOf( command_map ) === -1 ) {
          stage_list.push( command_map );
          stage_count++;
        }
      }
    }
    stage_idx++;
  }
  stage_list.sort( function ( a, b ) { return a.idx > b.idx; } );
  // . End expand stage list

  // Begin run stage list
  // Walk backward through list and bind functions.
  // The last function should have nextFn set to exit function,
  //   the second-to-last function should have nextFn set to
  //   the last function; the third-to-last function should have
  //   nextFn/ set to the second-to-last function, and so on.
  //
  // The CWD starts at the root project dirname.
  // Any modules that change the CWD should revert it before
  // running then_fn or catch_fn.
  //
  process.chdir( fqProjDirname );
  if ( stage_list.length > 1 ) {
    prefix_str  = 'Process range ' + param_map.range_str;
    range_start_str   = prefix_str + ' Start';
    range_success_str = prefix_str + ' Success';
  }

  xhi_obj.nextFn = function _nextFn () {
    exitFn( range_success_str );
  };

  stage_idx = stage_list.length - 1;
  while ( stage_idx > -1 ) {
    command_map        = stage_list[ stage_idx ];
    xhi_obj.commandMap = command_map;
    xhi_obj.paramMap   = param_map;

    // Load library
    stage_fn = require( fqLibDirname + '/xhi_' + command_map.id + '.js' );

    // Build exec chain
    bound_fn = stage_fn.bind( xhi_obj );
    exec_list.push( bound_fn );

    // Make new context object and set nextFn (catchFn === abortFn )
    if ( stage_idx > 0 ) {
      xhi_obj        = makeXhiObj();
      xhi_obj.nextFn = bound_fn;
    }
    stage_idx--;
  }
  logFn( range_start_str );
  if ( bound_fn ) { return bound_fn(); }
  // . End run stage list
}
// == . END PUBLIC METHOD /mainFn/ ====================================

// Begin Create state file if needed
// TODO 2017-09-01 mmikowski warn: Prefer routine to check all missing
// files and fill with default content.
fsObj.stat( fqStateFilename, function ( error_obj, ignore_map ) {
  var scratch_str;
  if ( error_obj ) {
    scratch_str = JSON.stringify( emptyStateMatrix, null, '  ' );
    fsObj.writeFile(
      fqStateFilename, scratch_str, { encoding : 'utf8' },
      initReadFn.bind({ then_fn : mainFn })
    );
  }
  else {
    initReadFn.call({ then_fn : mainFn });
  }
});
// . End Create state file if needed
// == . END SCRIPT xhi - the hi_score cli life-stage tool =============
